<h1>最小操作数</h1>

给你一个长度为n的整数数组，每次操作会使n-1个元素增加1.返回让数组所有元素相等的最小操作次数

<h3>示例1 </h3>


 输入: nums = [1,2,3] <br>
 输出: 3 <br>
 解释: 只需要3次操作(每次操作都会增加两个元素的值):
 [1,2,3] => [2,3,3] => [3,4,3] => [4,4,4]
 <br> 

 <h3>示例2 </h3>

 输入: nums = [1,1,1]</br>
 输出:0


<h2>方法一：数学:求对立事件</h2>

因为只需要找出让数组所有元素相等的最小操作数，所以我们不需要考虑数组中各个元素的绝对大小，即不需要真正算出数组中所有元素相等时的元素值，只需要考虑数组中元素相对大小的变化即可</br>
因此，每次操作既可以理解为使n-1个元素增加1，也可以理解事一个元素减少1.显然，后者更利于我们计算</br>

于是，要计算让数组中所有元素相等的操作数，我们只需要计算将数组中所有元素都减少到数组中元素最小值所需要的操作数，即计算

$$\sum^{n-1}_{i=0} nums[i] - min(nums)*n$$

其中$n$为数组$nums$的长度，$min(nums)$为数组$nums$中元素的最小值<br>

在实现中，为避免溢出，我们可以逐个累加每个元素与数组中元素最小值的差，即计算

$$\sum^{n-1}_{i=0}(nums[i]-min(nums))$$

<h2>C++题解</h2>

```C++
    class Solution{
        public:
            int minMoves(vector<int>&nums){
                int res = 0;
                for (int num:nums){
                    res += num-minNum;
                }
                return res;
            }
    }

```


<h2>python题解</h2>

```python
    class minMoves(self,nums:List[int])-> int:
        min_mun = min(nums)
        res = 0
        for num in numsL
            res += num - min_num
        return res

```

<h2>复杂度分析</h2>

时间复杂度:$O(n)$,其中$n$为数组中的元素数量，我们需要一次遍历求出最小值，一次遍历计算操作次数<br>
空间复杂度:$O(1)$