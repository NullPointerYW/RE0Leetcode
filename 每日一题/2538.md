<h1>统计美丽子数组数目</h1>

给你一个下标从**0**的整数数组`nums`,每次操作中，你可以:

- 选择两个满足`0 <= i, j < nums.length`的不同下标`i`和`j`.
- 选择一个非负整数`k`,满足`nums[i]`和`nums[j]`在二进制下的第`k`位
- 将`nums[i]`和`nums[j]`都减去$2^k$

如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为`0`的数组，那我们称它是一个 **美丽** 的子数组<br>

请你返回数组`nums`中 **美丽子数组**的数目<br>
子数组是一个数组中的一段连续 **非空**的元素序列

**示例1**

> 输入:`nums`=[4,3,1,2,4] <br>
> 输出:2 <br>
> 解释: nums中有 2 个美丽子数组：[4,**3,1,2**,4] 和 [**4,3,1,2,3**] <br>
> 按照下述步骤，我们可以将子数组[3,1,2]中所有元素变成 0:
> - 选择 [**3**,1,**2**] 和 k = 1.将 2 个数字都减去$2^1$，子数组变成[1,1,0]
> - 选择 [**1**,**1**,0] 和 k = 0,将 2 个数字都减去$2^0$, 子数组变成[0,0,0]
> 按照下述步骤，我们可以将子数组[4,3,1,2,4]中的所有元素变成 0 :
> - 选择 [**4**,3,1,2,**4**] 和 k = 2。 将 2 个数字都减去 $2^2$,子数组变成[0,3,1,2,0]
> - 选择 [0,**3**,**1**,2,0] 和 k = 0。 将 2 个数字都减去 $2^0$,子数组变成[0,2,0,2,0]
> - 选择 [0,**2**,0,**2**,0] 和 k = 1。 将 2 个数字都减去 $2^1$,子数组变成[0,0,0,0,0]

**示例2**
> 输入: nums = [1,10,4]<br>
> 输出:0
> 解释:nums 中没有任何美丽数组

<h2>前缀和</h2>
<h3>思路与算法</h3>

根据题目可以知，由于每次操作中需要从子数组中选择两个不同的数分别减去$2^k$,使得子数组中所有元素均变为0，由此可知对于子数组中所有元素$2^k$出现的次数之和必须为偶数。即对于二进制中第i位，则数组中所有元素第i位为1的数目一定为偶数，则此时满足数组中所有元素第i位的异或和一定为0 <br>

根据上述推论可知，如果给定的子数组 `nums[i...j]` 为**美丽子数组**，则此时一定满足：

$$nums[i]\oplus nums[i+1] \oplus nums[i+2] \oplus nums[i+3] \cdots nums[j]=0$$

此时我们只需要找到满足元素异或值为0的子数组即可。假设数组中前`j+1`个元素`nums[0...j]`异或的结果为x，即此时满足

$$nums[0]\oplus nums[1] \oplus nums[2] \oplus nums[3] \oplus ... nums[j] = x$$

则此时子数组`nums[k+1,...,j]`异或的结果一定为0，此时子数组`nums[]k+1,...,j`一定为**美丽子数组**,此时只需要找到数组`nums`满足前缀异或的结果为x的数目，即可以得到以`j`为结尾的**美丽子数组**的数目。<br>

实际计算时，可参考方法二的解法，设`p[i]`表示数组前缀`nums[0...i]`的异或值，我们依次从小到大枚举下标i，维护哈希表`cnt[x]`表示满足前缀异或值`p[j]=x`且`j<x`的数目，此时以`i`为结尾的**美丽子数组**的数目即为`cnt[p[i]]`,将数目累加到返回结果`ans`即可

<h3>C++</h3>

```C++
class Soltion{
public:
    long long beautifulSubarrays(vector<int>& nums){
        unordered_map<int,int> cnt;
        int mask = 0;
        long long ans = 0;
        cnt[0] = 1;
        for (int x :nums){
            mask ^=x;
            ans += cnt[mask];
            cnt[mask]++;
        }
        return ans;
    }
};

```

<h3>Python</h3>

```python 
class Solution:
    def beautifulSubarrays(self,nums:List[int]) -> int:
        cnt = {0:1}
        mask = 0
        ans = 0
        for x in nums:
            mask ^= x
            ans += cnt.get(mask,0)
            cnt[mask] = cnt.get(mask.0) + 1
        return ans

```

<h2>复杂度分析</h2>

- 时间复杂度:$o(n)$,其中 `n` 表示给定数组`nums`的长度。我们只需遍历一边数组即可，需要的时间为$o(n)$
- 空间复杂度:$o(n)$,其中 `n` 表示给定数组`nums`的长度，需要存储数组中前`i`个元素异或的值，需要的空间为$o(n)$